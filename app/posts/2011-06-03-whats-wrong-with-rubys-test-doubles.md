<h2>Prologue</h2>
<p>First things first: let&#8217;s square up terminology. For the sake of facilitating sane discussion on this topic, I&#8217;ve adopted the terms used in Gerard Meszaros&#8217; <a href="http://xunitpatterns.com/" target="_blank">XUnitPatterns book</a>. He drew a <a href="http://xunitpatterns.com/Mocks,%20Fakes,%20Stubs%20and%20Dummies.html" target="_blank">complex table</a> for this, but I&#8217;ll quickly summarize here:</p>
<ul><li><strong>Test Double — </strong>a generic term to describe an artifical stand-in for code (usually an object) upon which the subject code you&#8217;re specifying depends. Mocks, spies, stubs, fakes, etc. are all specific subtypes of test doubles.</li>
<li><strong>Stub</strong> — a test double that can be configured to respond to certain invocations (e.g. `when(panda.poke()).thenReturn(&#8220;chuckle&#8221;)`) in order to facilitate downstream behavior within your subject code. However, a stub can&#8217;t do anything to verify that certain invocations take place.</li>
<li><strong>Mock</strong> — a test double that can be configured to expect certain invocations <em>in advance</em>, raising exceptions if those interactions never occur. They add the bizarre wrinkle that if they receive any unexpected invocations, they&#8217;ll raise an exception. For convenience, the mock objects generated by most (all?) modern mock libraries can do double-duty as stubs, <a href="http://martinfowler.com/articles/mocksArentStubs.html" target="_blank">despite Martin Fowler&#8217;s best effort to explain all this</a>.</li>
<li><strong>Spy</strong> — a test double that records all of the invocations made against it, exposing some way to interrogate how it was interacted with <em>after the fact</em> (e.g. `verify(panda).eat(bamboo)`). Spies respond quietly when interacted with by your subject code, usually returning the bare minimum the language supports (`undefined` in JavaScript, `null` in Java, `nil` in Ruby). Of course, they respond less silently when they&#8217;ve been set up to stub an interaction, because most spies can stub too!</li>
<li><strong>Partial Mock / Proxy —</strong> a <em>real</em> object for which only particular method interactions have been cherry-picked to be stubbed or expected. Partial mocks break unit test isolation (because your subject code is now interacting with a quasi-real dependency) and their controversial use has been known to incite <a href="http://monkeyisland.pl/2009/01/13/subclass-and-override-vs-partial-mocking-vs-refactoring/" target="_blank">nerdy fisticuffs</a>.</li>
</ul><p>When it comes to test doubles available to Ruby developers, something has puzzled me for a while. Many of the brightest minds in testing <a href="http://pragprog.com/titles/fr_j2r/from-java-to-ruby" target="_blank">left Javaland</a> to join the Ruby community. Because of this, I was shocked to find that <a href="http://docs.mockito.googlecode.com/hg/org/mockito/Mockito.html" target="_blank">Mockito</a>—a test spy framework for Java—is a more expressive tool for working with generated test doubles than any of the numerous libraries available for Ruby.</p>
<h2>Mock Objects aren&#8217;t Fantastic</h2>
<p>One root cause of the problem seems to be buried in (relatively) ancient agile history. The popular concept of &#8220;mock objects&#8221; appears to have its roots in a <a href="http://connextra.com/aboutUs/mockobjects.pdf" target="_blank">paper submitted at XP 2000</a>. Mock objects were introduced as a sort of configurable booby trap: you can spring-load them to expect a discrete set of invocations; later when you execute your code, the mock will explode in your face if it was interacted with in any way other than what was explicitly expected in advance.</p>
<p>However, the pattern quickly earned popularity, because it lowered the barrier of entry for writing tests that isolated subject code from the implementation of its dependencies and verifying interactions that lacked observable side effects. And when I say &#8220;lowered the barrier of entry,&#8221; I mean to say, &#8220;hand-rolling test doubles in a language like Java produces mountains of cruft to maintain.&#8221;</p>
<p>Being in the business of specifying code using automated specs or unit tests, mock objects have always seemed to have a couple glaring flaws to the present author:</p>
<ul><li>Because expectations need to be declared up front, the developer is forced to violate the <a href="http://c2.com/cgi/wiki?ArrangeActAssert" target="_blank">arrange-act-assert pattern</a>. My challenged experience as a student of Japanese—where the verb is usually the last word in a sentence—concurs that it&#8217;s cumbersome to read every sentence to an &#8220;arrange-assert-act&#8221; rhythm.</li>
<li>Mock objects raise errors whenever they receive messages that weren&#8217;t explicitly expected. When a test double explodes for being interacted with in a way that may be irrelevant to the behavior being specified, it presents an unnecessary obstacle to any author intending to specify behavior over implementation.</li>
</ul><p>The introduction of the <a href="http://xunitpatterns.com/Test%20Spy.html" target="_blank">Spy</a> pattern alleviated these concerns. In fact, when <a href="http://dannorth.net/2008/09/14/the-end-of-endotesting" target="_blank">Dan North asked Mockito&#8217;s author</a> how he rose above the constraints imposed by traditional endotesting, <a href="http://monkeyisland.pl/about/" target="_blank">Szczepan Faber</a> replied, &#8220;what&#8217;s endotesting?&#8221; </p>
<h2>Ruby Test Doubles aren&#8217;t Fantastic</h2>
<p>Last summer, I wrapped up a project that benefited greatly from the low-maintenance semantics of spies in both <a href="http://mockito.org" target="_blank">Mockito</a> and <a href="https://github.com/pivotal/jasmine/wiki" target="_blank">Jasmine</a>. Following that experience, I was caught off guard as I worked through the otherwise fabulous <a href="http://pragprog.com/titles/achbd/the-rspec-book" target="_blank">RSpec Book</a>, because I failed to find the same enjoyable workflow in any of Ruby&#8217;s popular test double libraries. (For what it&#8217;s worth, I played with <a href="http://mocha.rubyforge.org/" target="_blank">Mocha</a>, <a href="http://relishapp.com/rspec/rspec-mocks" target="_blank">RSpec Mocks</a>, <a href="http://flexmock.rubyforge.org/" target="_blank">FlexMock</a>, <a href="http://notahat.com/not_a_mock/rdoc/" target="_blank">NotAMock</a>, and <a href="https://github.com/btakita/rr" target="_blank">rr</a>).</p>
<p>None of the libraries exhibited all of the following problems, but they all seemed to suffer from at least one of the following ails:</p>
<ul><li>In RSpec, performing the &#8220;arrange&#8221; and &#8220;act&#8221; steps in an example group&#8217;s `before` block can free up each `it` to be a one-line verification. This not only enables <a href="http://en.wikipedia.org/wiki/Don't_repeat_yourself" target="_blank">DRY</a>er specs, but when each `it` is just one line long, it can serve as an obvious English-to-code translation. Mock objects, which require expectations be set in advance of the &#8220;act&#8221; step, completely break this approach and force you back into larger `it` blocks that look more like traditional xUnit test methods.</li>
<li>As a result of the above, mock expectations also limit your ability to nest example groups—in which the &#8220;act&#8221; phase is performed in each `before` block and the behavior cascades into deeper example groups. It&#8217;s a shame, because nested example groups are a tremendously expressive ways to specify a subject as its state changes or when characterizing complex legacy code.</li>
<li>Some libraries rely on codifying methods as strings or symbols (e.g. `User.should_receive(:find).with(42)` instead of `verify(User).find(42)`), which makes refactoring method names harder. When a developer renames a method, she must remember to update references where the method is not only used like a method but also when it&#8217;s expressed as a symbolic argument.</li>
<li>None of the Ruby libraries seem to do anything to discourage &#8220;fantasy tests&#8221; (coined by <a href="https://twitter.com/jimweirich" target="_blank">Jim Weirich</a> in <a href="https://github.com/jimweirich/presentation_testing_why_dont_we_do_it_like_this" target="_blank">this talk</a>), which are unit tests that will stay green even after the depended-on-method&#8217;s name has changed. This problem doesn&#8217;t occur in Mockito (which has Java&#8217;s compile-time safety) and has never bitten me while using Jasmine (which has a simple runtime check that the function exists before creating each spy).</li>
<li>Since the primary reason I use test doubles is to achieve isolation from my subject code&#8217;s dependencies, I was disappointed by how eagerly some of the tools sought to break unit test isolation. For instance, <a href="https://github.com/nkallen/rr" target="_blank">rr&#8217;s proxy pattern</a> calls through to the real method. </li>
</ul><h2>The Way Forward</h2>
<p>Reviewing that list of foibles, I have to say I&#8217;m no longer astonished that it&#8217;s my rubyist friends who seem the most annoyed with, frustrated by, and often vehemently opposed to using test doubles. Instead, many rubyists are content to opt for (and Rails encourages) varying degrees of integrated tests when specifying code. However, insisting on only writing &#8221;most-stack&#8221; tests has consequences of its own, as <a href="http://blog.davidchelimsky.net/2008/12/11/a-case-against-a-case-against-mocking-and-stubbing/" target="_blank">David Chelimsky argued well</a>.</p>
<p>On the topic of &#8220;when to use a test double&#8221; (which my friend <a href="http://twitter.com/zachdennis" target="_blank">Zach Dennis</a> <a href="http://pragprog.com/magazines/2011-06/practical-mock-advice" target="_blank">wrote about</a> just this week), many developers I speak with seem to waste a lot of time throughout the day toiling over when and when not to employ test doubles when writing a code specification. Their concern is rooted in the astute observation that if they write only a single test to specify some code, a test that realistically integrates the code with its collaborators will provide more rich feedback than an isolated test will. This is absolutely true.</p>
<p>But these concerns seem to evaporate when one practices outside-in development, in which a failing full-stack spec (written in <a href="http://cukes.info/" target="_blank">Cucumber</a> or <a href="http://jeffkreeftmeijer.com/2010/steak-because-cucumber-is-for-vegetarians/" target="_blank">Steak</a>, perhaps) demands a failing unit specification, which in turn demands real code be written. It&#8217;s in this BDD cadence (advocated, again, by the RSpec book) where the decision of &#8220;when to mock&#8221; ceases to be so contentious. First, the code is already exercised in a fully-integrated setting, so if anything breaks, you&#8217;ll know about it. Second, the code can be specified safely and exhaustively under whatever degree of isolation makes for the cleanest, most readable spec. Finally, isolated specs are portable and can easily travel with the code, while the full-stack specs remain coupled to the broader application for which the code was first created.</p>
<h2>Gimme</h2>
<p>In response to all this, I spent two weeks over my Christmas holiday last year holed-up, writing a test spy library of my own called &#8220;<a href="https://github.com/searls/gimme" target="_blank">gimme</a>&#8221;. It was an exciting endeavor in learning a little bit about introspection in Ruby and specifying an API (without a user interface) using Cucumber.</p>
<p>I started gimme in an effort to escape each of the annoyances listed above. It has many of the features a test double library needs, like: stubbing, verifying, argument matchers, and <a href="http://mockito.googlecode.com/svn/tags/1.8.0/javadoc/org/mockito/ArgumentCaptor.html" target="_blank">argument captors</a>. However, gimme currently can&#8217;t stub or verify class methods, which more or less annihilates its usefulness for Rails apps.</p>
<p>Are you perhaps interested in helping poor gimme cross the finish line? <a href="http://twitter.com/kbaribeau" target="_blank">Kevin Baribeau</a> and I would love to meet more people interested in working on it.</p>
<p><span class="redacted">It seems like it would be ready for public consumption if it only had RSpec support and class method stubbing &amp; verification.</span> (Update: Gimme now supports both RSpec and class method stubbing and verification) <a href="http://twitter.com/searls" target="_blank">Tweet at me</a> or just <a href="https://github.com/searls/gimme" target="_blank">fork it yourself</a> if you&#8217;re interested in helping!</p>
<p><em>The fine print:</em></p>
<ul><li><em>I normally defend myself vigorously, but this is one case where I&#8217;d love to be exactly wrong, called out on it, and put to shame throughout the community. I&#8217;d happily suffer life as a disgrace if it meant there was a better test double library in Ruby and I was merely ignorant.</em></li>
<li><em>This post started out as a talk submission to <a href="http://greatlakesrubybash.com/" target="_blank">Great Lakes Ruby Bash</a>. They didn&#8217;t accept it, and perhaps for great reasons (read: I&#8217;m not awesome at Ruby).</em></li>
</ul>
