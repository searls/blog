<p>Ron Jeffries just posted a <a href="http://xprogramming.com/articles/too-much-of-a-good-thing/" target="_blank">terrific case for clean code</a>, and decoupled a recently-emerged &#8220;code can be too clean&#8221; meme from a question that has actual merit, &#8220;can we spend too much time making code clean?&#8221;</p>
<p>Upon discussing the post with <a href="http://twitter.com/kbaribeau" target="_blank">Kevin Baribeau</a> this evening, an anecdotal correlation was identified between folks who&#8217;ve said things akin to &#8220;code can be too clean&#8221; and folks who tend to succumb to the pressure to rush development of features.</p>
<p>I point this out not because this relationship would be surprising (it wouldn&#8217;t be), but because it might be causal. That is to say, antipathy toward time spent on clean code could be yet another dastardly consequence of rushing.</p>
<p>I seem to have observed the following downward spiral in the past. Given a developer who succumbs to the pressure to rush a feature or otherwise produce X widgets within a deadline when it stretches beyond his likely capacity:</p>
<ol><li>At work, there seems to be &#8220;no time&#8221; to either pause and write clean code or go back and clean up existing code.</li>
<li>Due to stress or overtime, there is no energy or drive left over to practice clean code independently (e.g. doing katas, side projects).</li>
<li>Falling out of practice, the individual&#8217;s ability to synthesize clean code will be weakened.</li>
<li>Eventually, the individual will acclimate to the pains of dirty code, and the only positive reinforcement they <em>ever</em> experience will be the (mild) success of delivering working dirty code.</li>
<li>Finally, the value of producing and maintaining clean code will be forgotten and a retort like &#8220;code can be too clean&#8221; might start to seem rational—particularly when viewed from the perspective of someone who began by overcommitting and for whom new features will be taking ever more time to write.</li>
</ol><p>Kevin pointed out that for this reason you want your team to stabilize at delivering around 80% of their potential capacity, to discourage the introduction of feedback loops like this one and to explicitly invest in the ability to rapidly respond to future changes. I tend to agree. One small step your team could make toward this ends would be to commit to only picking up stabilization cards (i.e. bugs or technical debt) on the day or two leading up to the close of an iteration.</p>
<p>This all seems so obvious that I question whether it&#8217;s worth posting here. So in case you&#8217;re in the choir and I&#8217;m merely preaching, I&#8217;ll end by recommending Andy Hunt&#8217;s terrific <em>Pragmatic Thinking and Learning </em>in case you haven&#8217;t read it, as it contains a terrific treatment on a related observation that <a href="http://www.pragprog.com/titles/ahptl/pragmatic-thinking-and-learning" target="_blank">pressure kills cognition</a>.</p>
